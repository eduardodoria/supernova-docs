{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Supernova Engine \u00b6 This is the official documentation and tutorials of Supernova. We are still in early development, so these documents can still be very incomplete. Note Docs is under development. Warning Supernova is not yet ready for production. Made for programmers Take a control of your game code. This is a game engine for real programmers. Simple and Fast Supernova doesn't have unnecessary stuffs like heavy GUI and extra processing. Lua or C++ You choose the best language is good for you. Lua and C++ can be used to make wonderful graphics and games. Cross-platform Write the code once and use it in Android, iOS and HTML5. It runs native in each platform with OpenGL ES. Sprites and animations A sprite object makes everything easy when working with animations . Dynamic shadows You can use many kind of lights with support for dynamic shadows. Getting started \u00b6 Creating a basic project Coordinate systems Building Supernova \u00b6 Building for Android Building for iOS Building for HTML5 (Emscripten) Learning \u00b6 Screen scaling Object animation Particle system","title":"Introduction"},{"location":"#supernova-engine","text":"This is the official documentation and tutorials of Supernova. We are still in early development, so these documents can still be very incomplete. Note Docs is under development. Warning Supernova is not yet ready for production. Made for programmers Take a control of your game code. This is a game engine for real programmers. Simple and Fast Supernova doesn't have unnecessary stuffs like heavy GUI and extra processing. Lua or C++ You choose the best language is good for you. Lua and C++ can be used to make wonderful graphics and games. Cross-platform Write the code once and use it in Android, iOS and HTML5. It runs native in each platform with OpenGL ES. Sprites and animations A sprite object makes everything easy when working with animations . Dynamic shadows You can use many kind of lights with support for dynamic shadows.","title":"Supernova Engine"},{"location":"#getting-started","text":"Creating a basic project Coordinate systems","title":"Getting started"},{"location":"#building-supernova","text":"Building for Android Building for iOS Building for HTML5 (Emscripten)","title":"Building Supernova"},{"location":"#learning","text":"Screen scaling Object animation Particle system","title":"Learning"},{"location":"getting-started/coordinate-systems/","text":"Under development...","title":"Coordinate systems"},{"location":"getting-started/creating-a-basic-project/","text":"In this example we will create a simple triangle. The same sample code can be used in any platform. File organization tree \u00b6 1. Using C++ \u00b6 In Supernova file tree there is a main.cpp file located in project/ folder. This file is used to start the game development in C++. As you can see, there is a call for supernova.h , that will call init() function when game started. Edit it with the code: C++ #include \"Supernova.h\" #include \"Scene.h\" #include \"Polygon.h\" #include \"Camera.h\" using namespace Supernova ; Polygon triangle ; Scene scene ; void init (){ Engine :: setCanvasSize ( 1000 , 480 ); triangle . addVertex ( Vector3 ( 0 , - 100 , 0 )); triangle . addVertex ( Vector3 ( - 50 , 50 , 0 )); triangle . addVertex ( Vector3 ( 50 , 50 , 0 )); triangle . setPosition ( Vector3 ( 300 , 300 , 0 )); triangle . setColor ( 0.6 , 0.2 , 0.6 , 1 ); scene . addObject ( & triangle ); Engine :: setScene ( & scene ); } If you have both Lua and C++ calling Supernova static method setScene() , the last call will be from Lua, so C++ code will not work. 2. Using Lua \u00b6 In Supernova file tree there is a main.lua file located in assets/lua/ folder. This file is used to start the game development in Lua. You can call any other Lua files by this. Edit it with the code: Lua Engine . setCanvasSize ( 1000 , 480 ) scene = Scene () triangle = Polygon () triangle : addVertex ( 0 , - 100 , 0 ) triangle : addVertex ( - 50 , 50 , 0 ) triangle : addVertex ( 50 , 50 , 0 ) triangle : setPosition ( 300 , 300 , 0 ) triangle : setColor ( 0.6 , 0.2 , 0.6 , 1 ) scene : addObject ( triangle ) Engine . setScene ( scene ) Now you can run to see the result.","title":"Creating a basic project"},{"location":"getting-started/creating-a-basic-project/#file-organization-tree","text":"","title":"File organization tree"},{"location":"getting-started/creating-a-basic-project/#1-using-c","text":"In Supernova file tree there is a main.cpp file located in project/ folder. This file is used to start the game development in C++. As you can see, there is a call for supernova.h , that will call init() function when game started. Edit it with the code: C++ #include \"Supernova.h\" #include \"Scene.h\" #include \"Polygon.h\" #include \"Camera.h\" using namespace Supernova ; Polygon triangle ; Scene scene ; void init (){ Engine :: setCanvasSize ( 1000 , 480 ); triangle . addVertex ( Vector3 ( 0 , - 100 , 0 )); triangle . addVertex ( Vector3 ( - 50 , 50 , 0 )); triangle . addVertex ( Vector3 ( 50 , 50 , 0 )); triangle . setPosition ( Vector3 ( 300 , 300 , 0 )); triangle . setColor ( 0.6 , 0.2 , 0.6 , 1 ); scene . addObject ( & triangle ); Engine :: setScene ( & scene ); } If you have both Lua and C++ calling Supernova static method setScene() , the last call will be from Lua, so C++ code will not work.","title":"1. Using C++"},{"location":"getting-started/creating-a-basic-project/#2-using-lua","text":"In Supernova file tree there is a main.lua file located in assets/lua/ folder. This file is used to start the game development in Lua. You can call any other Lua files by this. Edit it with the code: Lua Engine . setCanvasSize ( 1000 , 480 ) scene = Scene () triangle = Polygon () triangle : addVertex ( 0 , - 100 , 0 ) triangle : addVertex ( - 50 , 50 , 0 ) triangle : addVertex ( 50 , 50 , 0 ) triangle : setPosition ( 300 , 300 , 0 ) triangle : setColor ( 0.6 , 0.2 , 0.6 , 1 ) scene : addObject ( triangle ) Engine . setScene ( scene ) Now you can run to see the result.","title":"2. Using Lua"},{"location":"getting-started/building-project/building-for-android/","text":"Work for all platforms \u00b6 1. Clone Supernova project \u00b6 For Linux or OSX: \u00b6 Execute in terminal: git clone https://github.com/deslon/supernova.git For Windows: \u00b6 On Github, navigate to the main page of the repository. Under your repository name, click Clone or download . 2. Download and install Android Studio \u00b6 Download latest version of Android Studio (http://tools.android.com/download/studio/canary/latest). Install it following instructions. 3. Open project \u00b6 Open Android Studio, click in \"Open an existing Android Studio project\" and select workspace/android/ where Supernova was cloned. If asked to install Android NDK, CMake and or other addons, select yes.","title":"Building for Android"},{"location":"getting-started/building-project/building-for-android/#work-for-all-platforms","text":"","title":"Work for all platforms"},{"location":"getting-started/building-project/building-for-android/#1-clone-supernova-project","text":"","title":"1. Clone Supernova project"},{"location":"getting-started/building-project/building-for-android/#for-linux-or-osx","text":"Execute in terminal: git clone https://github.com/deslon/supernova.git","title":"For Linux or OSX:"},{"location":"getting-started/building-project/building-for-android/#for-windows","text":"On Github, navigate to the main page of the repository. Under your repository name, click Clone or download .","title":"For Windows:"},{"location":"getting-started/building-project/building-for-android/#2-download-and-install-android-studio","text":"Download latest version of Android Studio (http://tools.android.com/download/studio/canary/latest). Install it following instructions.","title":"2. Download and install Android Studio"},{"location":"getting-started/building-project/building-for-android/#3-open-project","text":"Open Android Studio, click in \"Open an existing Android Studio project\" and select workspace/android/ where Supernova was cloned. If asked to install Android NDK, CMake and or other addons, select yes.","title":"3. Open project"},{"location":"getting-started/building-project/building-for-html5/","text":"Work for all platforms \u00b6 1. Clone Supernova project \u00b6 For Linux or OSX: \u00b6 Execute in terminal: git clone https://github.com/deslon/supernova.git For Windows: \u00b6 On Github, navigate to the main page of the repository. Under your repository name, click Clone or download . 2. Download and install Emscripten \u00b6 Download from: https://kripken.github.io/emscripten-site/docs/getting_started/downloads.html Follow instructions depending of your platform: https://kripken.github.io/emscripten-site/docs/getting_started/downloads.html#installation-instructions For Linux and OSX you can do: . / emsdk update . / emsdk install sdk - 1 . 37 . 19 - 64 bit . / emsdk activate sdk - 1 . 37 . 19 - 64 bit For Windows, there is a simple installer. 3. Compile Supernova \u00b6 For Linux and OSX: \u00b6 Add Emscripten root to a system environment variable: export $EMSCRIPTEN=<path_to_emscripten> For Windows: \u00b6 Install MinGW: https://sourceforge.net/projects/mingw-w64/ Note that MinGW must be in PATH environment variable of Windows. To test it, try to run mingw32-make in Prompt. Install CMake: https://cmake.org/download/ During installation, choose to add to PATH. To test it, try to run cmake in Prompt. All platforms \u00b6 The directory where you clone Supernova go to: workspaces/emscripten/ Execute in terminal: python build.py When finished you can see generated .js and .html files in build/ folder. Open with any browser.","title":"Building for HTML5"},{"location":"getting-started/building-project/building-for-html5/#work-for-all-platforms","text":"","title":"Work for all platforms"},{"location":"getting-started/building-project/building-for-html5/#1-clone-supernova-project","text":"","title":"1. Clone Supernova project"},{"location":"getting-started/building-project/building-for-html5/#for-linux-or-osx","text":"Execute in terminal: git clone https://github.com/deslon/supernova.git","title":"For Linux or OSX:"},{"location":"getting-started/building-project/building-for-html5/#for-windows","text":"On Github, navigate to the main page of the repository. Under your repository name, click Clone or download .","title":"For Windows:"},{"location":"getting-started/building-project/building-for-html5/#2-download-and-install-emscripten","text":"Download from: https://kripken.github.io/emscripten-site/docs/getting_started/downloads.html Follow instructions depending of your platform: https://kripken.github.io/emscripten-site/docs/getting_started/downloads.html#installation-instructions For Linux and OSX you can do: . / emsdk update . / emsdk install sdk - 1 . 37 . 19 - 64 bit . / emsdk activate sdk - 1 . 37 . 19 - 64 bit For Windows, there is a simple installer.","title":"2. Download and install Emscripten"},{"location":"getting-started/building-project/building-for-html5/#3-compile-supernova","text":"","title":"3. Compile Supernova"},{"location":"getting-started/building-project/building-for-html5/#for-linux-and-osx","text":"Add Emscripten root to a system environment variable: export $EMSCRIPTEN=<path_to_emscripten>","title":"For Linux and OSX:"},{"location":"getting-started/building-project/building-for-html5/#for-windows_1","text":"Install MinGW: https://sourceforge.net/projects/mingw-w64/ Note that MinGW must be in PATH environment variable of Windows. To test it, try to run mingw32-make in Prompt. Install CMake: https://cmake.org/download/ During installation, choose to add to PATH. To test it, try to run cmake in Prompt.","title":"For Windows:"},{"location":"getting-started/building-project/building-for-html5/#all-platforms","text":"The directory where you clone Supernova go to: workspaces/emscripten/ Execute in terminal: python build.py When finished you can see generated .js and .html files in build/ folder. Open with any browser.","title":"All platforms"},{"location":"getting-started/building-project/building-for-ios/","text":"Work only for OSX \u00b6 1. Clone Supernova project \u00b6 Execute in terminal: git clone https://github.com/deslon/supernova.git 2. Download Xcode \u00b6 3. Open project \u00b6 In Supernova directory, open Xcode project workspace in: workspaces/ios/","title":"Building for iOS"},{"location":"getting-started/building-project/building-for-ios/#work-only-for-osx","text":"","title":"Work only for OSX"},{"location":"getting-started/building-project/building-for-ios/#1-clone-supernova-project","text":"Execute in terminal: git clone https://github.com/deslon/supernova.git","title":"1. Clone Supernova project"},{"location":"getting-started/building-project/building-for-ios/#2-download-xcode","text":"","title":"2. Download Xcode"},{"location":"getting-started/building-project/building-for-ios/#3-open-project","text":"In Supernova directory, open Xcode project workspace in: workspaces/ios/","title":"3. Open project"},{"location":"learning/object-animation/","text":"It`s possible to animate any object. This page explains how to make the animation work in many ways and ease functions. Animations in Supernova are made by Actions. These Actions can be used in all Scene objects. There are these types of actions: TimeAction MoveAction RotateAction ScaleAction ColorAction AlphaAction ParticlesAnimation SpriteAnimation Action control \u00b6 Any kind of action can be controlled with these tree main methods: Method Description run() Start an Action ou resume if is paused. stop() Stop and reset it timestamp. pause() Pause an Action, could be resumed with run(). Action events \u00b6 Also, you can use actions with these callback events: Event Description onStart(Object*) Called when Action is started (timestamp = 0). onRun(Object*) When method run() is called. onPause(Object*) When method pause() is called. onStop(Object*) When method stop() is called. onFinish(Object*) Called after finished Action. if loop is true this will never be called. onStep(Object*) Called at each iteration. Usually sync with onDraw engine event. TimeAction \u00b6 TimeAction is a generic type of action that has the values time and value . Both values can range from 0 to 1. The time is always fixed by a pre-defined duration, but value is calculated by an ease function. Value can be controlled by both pre-defined functions and user-defined functions. Getting value and time from Action: C++ float time = action . getTime (); float value = action . getValue (); Lua time = action : getTime () value = action : getValue () Class default constructor: TimeAction(float duration, bool loop) Example how to use TimeAction that is activating on touch start and on every step triangle is moved: C++ #include \"Supernova.h\" #include \"Scene.h\" #include \"Polygon.h\" #include \"Camera.h\" #include \"TimeAction.h\" #include \"MoveAction.h\" using namespace Supernova ; Polygon triangle ; Scene scene ; TimeAction * action ; void onActionOnStep ( Object * object ); void onTouchStart ( float x , float y ); void init (){ Engine :: setCanvasSize ( 1000 , 480 ); triangle . addVertex ( Vector3 ( 0 , - 100 , 0 )); triangle . addVertex ( Vector3 ( - 50 , 50 , 0 )); triangle . addVertex ( Vector3 ( 50 , 50 , 0 )); triangle . setPosition ( Vector3 ( 300 , 300 , 0 )); triangle . setColor ( 0.6 , 0.2 , 0.6 , 1 ); scene . addObject ( & triangle ); action = new TimeAction ( 2 , true ); action -> setFunctionType ( S_LINEAR ); triangle . addAction ( action ); action -> onStep = onActionOnStep ; Engine :: setScene ( & scene ); Engine :: onTouchPress = onTouchPress ; } void onActionOnStep ( Object * object ){ object -> setPosition ( 200 + action -> getValue () * 100 , 200 ); } void onTouchStart ( float x , float y ){ if ( action -> isRunning ()) action -> pause (); else action -> run (); } Lua Engine . setCanvasSize ( 1000 , 480 ) scene = Scene () triangle = Polygon () triangle : addVertex ( 0 , - 100 , 0 ) triangle : addVertex ( - 50 , 50 , 0 ) triangle : addVertex ( 50 , 50 , 0 ) triangle : setPosition ( 300 , 300 , 0 ) triangle : setColor ( 0.6 , 0.2 , 0.6 , 1 ) scene : addObject ( triangle ) action = TimeAction ( 2 , false ) action : setFunctionType ( TimeAction . LINEAR ) triangle : addAction ( action ) Engine . setScene ( scene ) function onActionOnStep ( object ) object : setPosition2D ( 200 + action : getValue () * 100 , 200 ); end action . onStep = onActionOnStep function onTouchStart ( x , y ) if ( action : isRunning ()) then action : pause () else action : run () end end Engine . onTouchPress = onTouchPress Similar to the previous example, the same function can be used with MoveAction instead of TimeAction . This time it is no longer necessary to use onStep() : C++ #include \"Supernova.h\" #include \"Scene.h\" #include \"Polygon.h\" #include \"Camera.h\" #include \"MoveAction.h\" using namespace Supernova ; Polygon triangle ; Scene scene ; MoveAction * action ; void onTouchStart ( float x , float y ); void init (){ Engine :: setCanvasSize ( 1000 , 480 ); triangle . addVertex ( Vector3 ( 0 , - 100 , 0 )); triangle . addVertex ( Vector3 ( - 50 , 50 , 0 )); triangle . addVertex ( Vector3 ( 50 , 50 , 0 )); triangle . setPosition ( Vector3 ( 300 , 300 , 0 )); triangle . setColor ( 0.6 , 0.2 , 0.6 , 1 ); scene . addObject ( & triangle ); action = new MoveAction ( triangle . getPosition (), Vector3 ( 0 , 10 , 0 ), 2 , true ); action -> setFunctionType ( S_LINEAR ); triangle . addAction ( action ); action -> run (); Engine :: setScene ( & scene ); Engine :: onTouchPress = onTouchPress ; } void onTouchStart ( float x , float y ){ if ( action -> isRunning ()) action -> pause (); else action -> run (); } Lua Engine . setCanvasSize ( 1000 , 480 ) scene = Scene () triangle = Polygon () triangle : addVertex ( 0 , - 100 , 0 ) triangle : addVertex ( - 50 , 50 , 0 ) triangle : addVertex ( 50 , 50 , 0 ) triangle : setPosition ( 300 , 300 , 0 ) triangle : setColor ( 0.6 , 0.2 , 0.6 , 1 ) scene : addObject ( triangle ) action = MoveAction ( triangle . position , Vector3 ( 500 , 700 , 0 ), 2 , true ) action : setFunctionType ( Action . EASE_ELASTIC_IN_OUT ) triangle : addAction ( action ) action : run () Engine . setScene ( scene ) function onTouchStart ( x , y ) if ( action : isRunning ()) then action : pause () else action : run () end end Engine . onTouchPress = onTouchPress ; Pre-defined ease functions \u00b6 Linear \u00b6 C++ action . setFunctionType ( S_LINEAR ); Lua action : setFunctionType ( TimeAction . LINEAR ); Quad \u00b6 C++ action . setFunctionType ( S_EASE_QUAD_IN ); action . setFunctionType ( S_EASE_QUAD_OUT ); action . setFunctionType ( S_EASE_QUAD_IN_OUT ); Lua action : setFunctionType ( Action . EASE_QUAD_IN ); action : setFunctionType ( Action . EASE_QUAD_OUT ); action : setFunctionType ( Action . EASE_QUAD_IN_OUT ); Cubic \u00b6 C++ action . setFunctionType ( S_EASE_CUBIC_IN ); action . setFunctionType ( S_EASE_CUBIC_OUT ); action . setFunctionType ( S_EASE_CUBIC_IN_OUT ); Lua action : setFunctionType ( Action . EASE_CUBIC_IN ); action : setFunctionType ( Action . EASE_CUBIC_OUT ); action : setFunctionType ( Action . EASE_CUBIC_IN_OUT ); Quart \u00b6 C++ action . setFunctionType ( S_EASE_QUART_IN ); action . setFunctionType ( S_EASE_QUART_OUT ); action . setFunctionType ( S_EASE_QUART_IN_OUT ); Lua action : setFunctionType ( Action . EASE_QUART_IN ); action : setFunctionType ( Action . EASE_QUART_OUT ); action : setFunctionType ( Action . EASE_QUART_IN_OUT ); Quint \u00b6 C++ action . setFunctionType ( S_EASE_QUINT_IN ); action . setFunctionType ( S_EASE_QUINT_OUT ); action . setFunctionType ( S_EASE_QUINT_IN_OUT ); Lua action : setFunctionType ( Action . EASE_QUINT_IN ); action : setFunctionType ( Action . EASE_QUINT_OUT ); action : setFunctionType ( Action . EASE_QUINT_IN_OUT ); Sine \u00b6 C++ action . setFunctionType ( S_EASE_SINE_IN ); action . setFunctionType ( S_EASE_SINE_OUT ); action . setFunctionType ( S_EASE_SINE_IN_OUT ); Lua action : setFunctionType ( Action . EASE_SINE_IN ); action : setFunctionType ( Action . EASE_SINE_OUT ); action : setFunctionType ( Action . EASE_SINE_IN_OUT ); Expo \u00b6 C++ action . setFunctionType ( S_EASE_EXPO_IN ); action . setFunctionType ( S_EASE_EXPO_OUT ); action . setFunctionType ( S_EASE_EXPO_IN_OUT ); Lua action : setFunctionType ( Action . EASE_EXPO_IN ); action : setFunctionType ( Action . EASE_EXPO_OUT ); action : setFunctionType ( Action . EASE_EXPO_IN_OUT ); Circ \u00b6 C++ action . setFunctionType ( S_EASE_CIRC_IN ); action . setFunctionType ( S_EASE_CIRC_OUT ); action . setFunctionType ( S_EASE_CIRC_IN_OUT ); Lua action : setFunctionType ( Action . EASE_CIRC_IN ); action : setFunctionType ( Action . EASE_CIRC_OUT ); action : setFunctionType ( Action . EASE_CIRC_IN_OUT ); Elastic \u00b6 C++ action . setFunctionType ( S_EASE_ELASTIC_IN ); action . setFunctionType ( S_EASE_ELASTIC_OUT ); action . setFunctionType ( S_EASE_ELASTIC_IN_OUT ); Lua action : setFunctionType ( Action . EASE_ELASTIC_IN ); action : setFunctionType ( Action . EASE_ELASTIC_OUT ); action : setFunctionType ( Action . EASE_ELASTIC_IN_OUT ); Back \u00b6 C++ action . setFunctionType ( S_EASE_BACK_IN ); action . setFunctionType ( S_EASE_BACK_OUT ); action . setFunctionType ( S_EASE_BACK_IN_OUT ); Lua action : setFunctionType ( Action . EASE_BACK_IN ); action : setFunctionType ( Action . EASE_BACK_OUT ); action : setFunctionType ( Action . EASE_BACK_IN_OUT ); Bounce \u00b6 C++ action . setFunctionType ( S_EASE_BOUNCE_IN ); action . setFunctionType ( S_EASE_BOUNCE_OUT ); action . setFunctionType ( S_EASE_BOUNCE_IN_OUT ); Lua action : setFunctionType ( Action . EASE_BOUNCE_IN ); action : setFunctionType ( Action . EASE_BOUNCE_OUT ); action : setFunctionType ( Action . EASE_BOUNCE_IN_OUT ); User-defined ease functions \u00b6 It's also possible to create new functions and attach it to a TimeAction. C++ float newFunction ( float time ){ return time * 2 ; } action . setFunction ( newFunction ); Lua function newFunction ( time ) return time * 2 end action : setFunction ( newFunction ); MoveAction \u00b6 Is used to generate a movement in objects. Class default constructor: MoveAction(Vector3 startPosition, Vector3 endPosition, float duration, bool loop=false) C++ action = new MoveAction ( Vector3 ( 100 , 200 , 0 ), Vector3 ( 0 , 10 , 0 ), 2 , false ); Lua action = MoveAction ( Vector3 ( 100 , 200 , 0 ), Vector3 ( 0 , 10 , 0 ), 2 , true ) RotateAction \u00b6 Is used to generate rotation in objects. Rotations are made by quaternions, but you can easily a create quaternions with angles. Class default constructor: RotateAction(Quaternion startRotation, Quaternion endRotation, float duration, bool loop=false) C++ Quaternion fromAngle ; fromAngle . fromAngle ( 20 ); Quaternion toAngle ; toAngle . fromAngle ( 80 ); action = new RotateAction ( fromAngle , toAngle , 5 , true ); Lua fromAngle = Quaternion () fromAngle : fromAngle ( 20 ) toAngle = Quaternion () toAngle : fromAngle ( 80 ) action = RotateAction ( fromAngle , toAngle , 2 , true ) For default, a Quaternion method fromAngleAxis uses axis Z (for 2D projects) to perform a rotation, but it`s also possible to make rotations for any axis: C++ fromAngle . fromAngleAxis ( 20 , Vector3 ( 0 , 1 , 0 )); Lua fromAngle : fromAngleAxis ( 10 , Vector3 ( 0 , 1 , 0 )) ScaleAction \u00b6 Is used to change object scale. Scales are setting by Vector3. For example, if you want increase the object 3 times from Y axis you can use Vector3(1, 3, 1) . Class default constructor: ScaleAction(Vector3 startScale, Vector3 endScalel, float duration, bool loop=false) C++ action = new ScaleAction ( Vector3 ( 1 , 1 , 1 ), Vector3 ( 1 , 10 , 1 ), 2 , true ); Lua action = ScaleAction ( Vector3 ( 1 , 1 , 1 ), Vector3 ( 1 , 10 , 1 ), 2 , true ) ColorAction \u00b6 Is used to change the color of object. Class default constructor: ColorAction(float startRed, float startGreen, float startBlue, float endRed, float endGreen, float endBlue, float duration, bool loop=false) C++ action = new ColorAction ( 0 , 0.5 , 0.8 , 1 , 0.4 , 0 , 5 , true ); Lua action = ColorAction ( 0 , 0.5 , 0.8 , 1 , 0.4 , 0 , 5 , true ) AlphaAction \u00b6 Is used to change alpha factor of object. Alpha 1.0 \u00e9 full opaque object and alpha 0.0 is full transparent object. Class default constructor: AlphaAction(float startAlpha, float endAlpha, float duration, bool loop=false) C++ action = new AlphaAction ( 1 , 0 , 5 , true ); Lua action = AlphaAction ( 1 , 0 , 5 , true )","title":"Object animation"},{"location":"learning/object-animation/#action-control","text":"Any kind of action can be controlled with these tree main methods: Method Description run() Start an Action ou resume if is paused. stop() Stop and reset it timestamp. pause() Pause an Action, could be resumed with run().","title":"Action control"},{"location":"learning/object-animation/#action-events","text":"Also, you can use actions with these callback events: Event Description onStart(Object*) Called when Action is started (timestamp = 0). onRun(Object*) When method run() is called. onPause(Object*) When method pause() is called. onStop(Object*) When method stop() is called. onFinish(Object*) Called after finished Action. if loop is true this will never be called. onStep(Object*) Called at each iteration. Usually sync with onDraw engine event.","title":"Action events"},{"location":"learning/object-animation/#timeaction","text":"TimeAction is a generic type of action that has the values time and value . Both values can range from 0 to 1. The time is always fixed by a pre-defined duration, but value is calculated by an ease function. Value can be controlled by both pre-defined functions and user-defined functions. Getting value and time from Action: C++ float time = action . getTime (); float value = action . getValue (); Lua time = action : getTime () value = action : getValue () Class default constructor: TimeAction(float duration, bool loop) Example how to use TimeAction that is activating on touch start and on every step triangle is moved: C++ #include \"Supernova.h\" #include \"Scene.h\" #include \"Polygon.h\" #include \"Camera.h\" #include \"TimeAction.h\" #include \"MoveAction.h\" using namespace Supernova ; Polygon triangle ; Scene scene ; TimeAction * action ; void onActionOnStep ( Object * object ); void onTouchStart ( float x , float y ); void init (){ Engine :: setCanvasSize ( 1000 , 480 ); triangle . addVertex ( Vector3 ( 0 , - 100 , 0 )); triangle . addVertex ( Vector3 ( - 50 , 50 , 0 )); triangle . addVertex ( Vector3 ( 50 , 50 , 0 )); triangle . setPosition ( Vector3 ( 300 , 300 , 0 )); triangle . setColor ( 0.6 , 0.2 , 0.6 , 1 ); scene . addObject ( & triangle ); action = new TimeAction ( 2 , true ); action -> setFunctionType ( S_LINEAR ); triangle . addAction ( action ); action -> onStep = onActionOnStep ; Engine :: setScene ( & scene ); Engine :: onTouchPress = onTouchPress ; } void onActionOnStep ( Object * object ){ object -> setPosition ( 200 + action -> getValue () * 100 , 200 ); } void onTouchStart ( float x , float y ){ if ( action -> isRunning ()) action -> pause (); else action -> run (); } Lua Engine . setCanvasSize ( 1000 , 480 ) scene = Scene () triangle = Polygon () triangle : addVertex ( 0 , - 100 , 0 ) triangle : addVertex ( - 50 , 50 , 0 ) triangle : addVertex ( 50 , 50 , 0 ) triangle : setPosition ( 300 , 300 , 0 ) triangle : setColor ( 0.6 , 0.2 , 0.6 , 1 ) scene : addObject ( triangle ) action = TimeAction ( 2 , false ) action : setFunctionType ( TimeAction . LINEAR ) triangle : addAction ( action ) Engine . setScene ( scene ) function onActionOnStep ( object ) object : setPosition2D ( 200 + action : getValue () * 100 , 200 ); end action . onStep = onActionOnStep function onTouchStart ( x , y ) if ( action : isRunning ()) then action : pause () else action : run () end end Engine . onTouchPress = onTouchPress Similar to the previous example, the same function can be used with MoveAction instead of TimeAction . This time it is no longer necessary to use onStep() : C++ #include \"Supernova.h\" #include \"Scene.h\" #include \"Polygon.h\" #include \"Camera.h\" #include \"MoveAction.h\" using namespace Supernova ; Polygon triangle ; Scene scene ; MoveAction * action ; void onTouchStart ( float x , float y ); void init (){ Engine :: setCanvasSize ( 1000 , 480 ); triangle . addVertex ( Vector3 ( 0 , - 100 , 0 )); triangle . addVertex ( Vector3 ( - 50 , 50 , 0 )); triangle . addVertex ( Vector3 ( 50 , 50 , 0 )); triangle . setPosition ( Vector3 ( 300 , 300 , 0 )); triangle . setColor ( 0.6 , 0.2 , 0.6 , 1 ); scene . addObject ( & triangle ); action = new MoveAction ( triangle . getPosition (), Vector3 ( 0 , 10 , 0 ), 2 , true ); action -> setFunctionType ( S_LINEAR ); triangle . addAction ( action ); action -> run (); Engine :: setScene ( & scene ); Engine :: onTouchPress = onTouchPress ; } void onTouchStart ( float x , float y ){ if ( action -> isRunning ()) action -> pause (); else action -> run (); } Lua Engine . setCanvasSize ( 1000 , 480 ) scene = Scene () triangle = Polygon () triangle : addVertex ( 0 , - 100 , 0 ) triangle : addVertex ( - 50 , 50 , 0 ) triangle : addVertex ( 50 , 50 , 0 ) triangle : setPosition ( 300 , 300 , 0 ) triangle : setColor ( 0.6 , 0.2 , 0.6 , 1 ) scene : addObject ( triangle ) action = MoveAction ( triangle . position , Vector3 ( 500 , 700 , 0 ), 2 , true ) action : setFunctionType ( Action . EASE_ELASTIC_IN_OUT ) triangle : addAction ( action ) action : run () Engine . setScene ( scene ) function onTouchStart ( x , y ) if ( action : isRunning ()) then action : pause () else action : run () end end Engine . onTouchPress = onTouchPress ;","title":"TimeAction"},{"location":"learning/object-animation/#pre-defined-ease-functions","text":"","title":"Pre-defined ease functions"},{"location":"learning/object-animation/#linear","text":"C++ action . setFunctionType ( S_LINEAR ); Lua action : setFunctionType ( TimeAction . LINEAR );","title":"Linear"},{"location":"learning/object-animation/#quad","text":"C++ action . setFunctionType ( S_EASE_QUAD_IN ); action . setFunctionType ( S_EASE_QUAD_OUT ); action . setFunctionType ( S_EASE_QUAD_IN_OUT ); Lua action : setFunctionType ( Action . EASE_QUAD_IN ); action : setFunctionType ( Action . EASE_QUAD_OUT ); action : setFunctionType ( Action . EASE_QUAD_IN_OUT );","title":"Quad"},{"location":"learning/object-animation/#cubic","text":"C++ action . setFunctionType ( S_EASE_CUBIC_IN ); action . setFunctionType ( S_EASE_CUBIC_OUT ); action . setFunctionType ( S_EASE_CUBIC_IN_OUT ); Lua action : setFunctionType ( Action . EASE_CUBIC_IN ); action : setFunctionType ( Action . EASE_CUBIC_OUT ); action : setFunctionType ( Action . EASE_CUBIC_IN_OUT );","title":"Cubic"},{"location":"learning/object-animation/#quart","text":"C++ action . setFunctionType ( S_EASE_QUART_IN ); action . setFunctionType ( S_EASE_QUART_OUT ); action . setFunctionType ( S_EASE_QUART_IN_OUT ); Lua action : setFunctionType ( Action . EASE_QUART_IN ); action : setFunctionType ( Action . EASE_QUART_OUT ); action : setFunctionType ( Action . EASE_QUART_IN_OUT );","title":"Quart"},{"location":"learning/object-animation/#quint","text":"C++ action . setFunctionType ( S_EASE_QUINT_IN ); action . setFunctionType ( S_EASE_QUINT_OUT ); action . setFunctionType ( S_EASE_QUINT_IN_OUT ); Lua action : setFunctionType ( Action . EASE_QUINT_IN ); action : setFunctionType ( Action . EASE_QUINT_OUT ); action : setFunctionType ( Action . EASE_QUINT_IN_OUT );","title":"Quint"},{"location":"learning/object-animation/#sine","text":"C++ action . setFunctionType ( S_EASE_SINE_IN ); action . setFunctionType ( S_EASE_SINE_OUT ); action . setFunctionType ( S_EASE_SINE_IN_OUT ); Lua action : setFunctionType ( Action . EASE_SINE_IN ); action : setFunctionType ( Action . EASE_SINE_OUT ); action : setFunctionType ( Action . EASE_SINE_IN_OUT );","title":"Sine"},{"location":"learning/object-animation/#expo","text":"C++ action . setFunctionType ( S_EASE_EXPO_IN ); action . setFunctionType ( S_EASE_EXPO_OUT ); action . setFunctionType ( S_EASE_EXPO_IN_OUT ); Lua action : setFunctionType ( Action . EASE_EXPO_IN ); action : setFunctionType ( Action . EASE_EXPO_OUT ); action : setFunctionType ( Action . EASE_EXPO_IN_OUT );","title":"Expo"},{"location":"learning/object-animation/#circ","text":"C++ action . setFunctionType ( S_EASE_CIRC_IN ); action . setFunctionType ( S_EASE_CIRC_OUT ); action . setFunctionType ( S_EASE_CIRC_IN_OUT ); Lua action : setFunctionType ( Action . EASE_CIRC_IN ); action : setFunctionType ( Action . EASE_CIRC_OUT ); action : setFunctionType ( Action . EASE_CIRC_IN_OUT );","title":"Circ"},{"location":"learning/object-animation/#elastic","text":"C++ action . setFunctionType ( S_EASE_ELASTIC_IN ); action . setFunctionType ( S_EASE_ELASTIC_OUT ); action . setFunctionType ( S_EASE_ELASTIC_IN_OUT ); Lua action : setFunctionType ( Action . EASE_ELASTIC_IN ); action : setFunctionType ( Action . EASE_ELASTIC_OUT ); action : setFunctionType ( Action . EASE_ELASTIC_IN_OUT );","title":"Elastic"},{"location":"learning/object-animation/#back","text":"C++ action . setFunctionType ( S_EASE_BACK_IN ); action . setFunctionType ( S_EASE_BACK_OUT ); action . setFunctionType ( S_EASE_BACK_IN_OUT ); Lua action : setFunctionType ( Action . EASE_BACK_IN ); action : setFunctionType ( Action . EASE_BACK_OUT ); action : setFunctionType ( Action . EASE_BACK_IN_OUT );","title":"Back"},{"location":"learning/object-animation/#bounce","text":"C++ action . setFunctionType ( S_EASE_BOUNCE_IN ); action . setFunctionType ( S_EASE_BOUNCE_OUT ); action . setFunctionType ( S_EASE_BOUNCE_IN_OUT ); Lua action : setFunctionType ( Action . EASE_BOUNCE_IN ); action : setFunctionType ( Action . EASE_BOUNCE_OUT ); action : setFunctionType ( Action . EASE_BOUNCE_IN_OUT );","title":"Bounce"},{"location":"learning/object-animation/#user-defined-ease-functions","text":"It's also possible to create new functions and attach it to a TimeAction. C++ float newFunction ( float time ){ return time * 2 ; } action . setFunction ( newFunction ); Lua function newFunction ( time ) return time * 2 end action : setFunction ( newFunction );","title":"User-defined ease functions"},{"location":"learning/object-animation/#moveaction","text":"Is used to generate a movement in objects. Class default constructor: MoveAction(Vector3 startPosition, Vector3 endPosition, float duration, bool loop=false) C++ action = new MoveAction ( Vector3 ( 100 , 200 , 0 ), Vector3 ( 0 , 10 , 0 ), 2 , false ); Lua action = MoveAction ( Vector3 ( 100 , 200 , 0 ), Vector3 ( 0 , 10 , 0 ), 2 , true )","title":"MoveAction"},{"location":"learning/object-animation/#rotateaction","text":"Is used to generate rotation in objects. Rotations are made by quaternions, but you can easily a create quaternions with angles. Class default constructor: RotateAction(Quaternion startRotation, Quaternion endRotation, float duration, bool loop=false) C++ Quaternion fromAngle ; fromAngle . fromAngle ( 20 ); Quaternion toAngle ; toAngle . fromAngle ( 80 ); action = new RotateAction ( fromAngle , toAngle , 5 , true ); Lua fromAngle = Quaternion () fromAngle : fromAngle ( 20 ) toAngle = Quaternion () toAngle : fromAngle ( 80 ) action = RotateAction ( fromAngle , toAngle , 2 , true ) For default, a Quaternion method fromAngleAxis uses axis Z (for 2D projects) to perform a rotation, but it`s also possible to make rotations for any axis: C++ fromAngle . fromAngleAxis ( 20 , Vector3 ( 0 , 1 , 0 )); Lua fromAngle : fromAngleAxis ( 10 , Vector3 ( 0 , 1 , 0 ))","title":"RotateAction"},{"location":"learning/object-animation/#scaleaction","text":"Is used to change object scale. Scales are setting by Vector3. For example, if you want increase the object 3 times from Y axis you can use Vector3(1, 3, 1) . Class default constructor: ScaleAction(Vector3 startScale, Vector3 endScalel, float duration, bool loop=false) C++ action = new ScaleAction ( Vector3 ( 1 , 1 , 1 ), Vector3 ( 1 , 10 , 1 ), 2 , true ); Lua action = ScaleAction ( Vector3 ( 1 , 1 , 1 ), Vector3 ( 1 , 10 , 1 ), 2 , true )","title":"ScaleAction"},{"location":"learning/object-animation/#coloraction","text":"Is used to change the color of object. Class default constructor: ColorAction(float startRed, float startGreen, float startBlue, float endRed, float endGreen, float endBlue, float duration, bool loop=false) C++ action = new ColorAction ( 0 , 0.5 , 0.8 , 1 , 0.4 , 0 , 5 , true ); Lua action = ColorAction ( 0 , 0.5 , 0.8 , 1 , 0.4 , 0 , 5 , true )","title":"ColorAction"},{"location":"learning/object-animation/#alphaaction","text":"Is used to change alpha factor of object. Alpha 1.0 \u00e9 full opaque object and alpha 0.0 is full transparent object. Class default constructor: AlphaAction(float startAlpha, float endAlpha, float duration, bool loop=false) C++ action = new AlphaAction ( 1 , 0 , 5 , true ); Lua action = AlphaAction ( 1 , 0 , 5 , true )","title":"AlphaAction"},{"location":"learning/particle-system/","text":"In Supernova to use particle system you have to create two kind of objects: Particle Initializers and Particle Modifiers. Particle Initializers ParticleLifeInit ParticlePositionInit ParticleRotationInit ParticleAlphaInit ParticleColorInit ParticleSizeInit ParticleSpriteInit ParticleVelocityInit ParticleAccelerationInit Particle Modifiers ParticleAlphaMod ParticleColorMod ParticlePositionMod ParticleRotationMod ParticleSizeMod ParticleSpriteMod ParticleVelocityMod Here is an example how Inittializers and Modifiers can be used to create particles animation. C++ #include \"Supernova.h\" #include \"Scene.h\" #include \"Particles.h\" #include \"ParticlesAnimation.h\" #include \"ParticleLifeInit.h\" #include \"ParticleSizeInit.h\" #include \"ParticleVelocityInit.h\" #include \"ParticleColorMod.h\" #include \"ParticleRotationMod.h\" using namespace Supernova ; Scene scene ; Particles * particles ; ParticlesAnimation * particlesanim ; void init (){ Engine :: setCanvasSize ( 1000 , 480 ); particles = new Particles (); particlesanim = new ParticlesAnimation (); particles -> setRate ( 10 ); particles -> setMaxParticles ( 100 );; particles -> setTexture ( \"f4.png\" ); particles -> setPosition ( 200 , 200 , 0 ); particles -> addAction ( particlesanim ); particlesanim -> addInit ( new ParticleLifeInit ( 10 , 10 )); particlesanim -> addInit ( new ParticleSizeInit ( 50 , 100 )); particlesanim -> addInit ( new ParticleVelocityInit ( Vector3 ( - 15 , - 4 , 0 ), Vector3 ( 15 , 24 , 0 ))); particlesanim -> addMod ( new ParticleColorMod ( 10 , 0 , 0 , 1 , 0 , 1 , 0 , 0 )); particlesanim -> addMod ( new ParticleRotationMod ( 9 , 1 , 0 , 180 )); particlesanim -> run (); scene . addObject ( particles ); Engine :: setScene ( & scene ); } Lua Engine . setCanvasSize ( 1000 , 480 ) scene = Scene () particles = Particles () particlesanim = ParticlesAnimation () particles : setRate ( 10 ) particles : setMaxParticles ( 100 ) particles : setTexture ( \"f4.png\" ) particles : setPosition ( 200 , 200 , 0 ) particles : addAction ( particlesanim ) particlesanim : addInit ( ParticleLifeInit ( 10 , 10 )) particlesanim : addInit ( ParticleSizeInit ( 50 , 100 )) particlesanim : addInit ( ParticleVelocityInit ( Vector3 ( - 15 , - 4 , 0 ), Vector3 ( 15 , 24 , 0 ))) particlesanim : addMod ( ParticleColorMod ( 10 , 0 , 0 , 1 , 0 , 1 , 0 , 0 )) particlesanim : addMod ( ParticleRotationMod ( 9 , 1 , 0 , 180 )) particlesanim : run () scene : addObject ( particles ) Engine . setScene ( scene ) Particle Initializers \u00b6 ParticleLifeInit \u00b6 Every particle has its life and this life is regressive. When a particle starts, through this class you can set the lifetime of it. Throughout the life of the particle, when it reaches 0, the particle dies. Class default constructor: ParticleLifeInit(float minLife, float maxLife) C++ particlesanim -> addInit ( new ParticleLifeInit ( 10 , 10 )); Lua particlesanim : addInit ( ParticleLifeInit ( 10 , 10 )) ParticlePositionInit \u00b6 The inittial position of particle is set with this class. Class default constructor: ParticlePositionInit(Vector3 minPosition, Vector3 maxPosition) C++ particlesanim -> addInit ( new ParticlePositionInit ( Vector3 ( 100 , 0 , 0 ), Vector3 ( 100 , 100 , 0 ))); Lua particlesanim : addInit ( ParticlePositionInit ( Vector3 ( 100 , 0 , 0 ), Vector3 ( 100 , 100 , 0 ))) ParticleRotationInit \u00b6 The inittial rotation of particle is set with this class. The engine default is degress, but it can be changed. Class default constructor: ParticleRotationInit(float minRotation, float maxRotation) C++ particlesanim -> addInit ( new ParticleRotationInit ( 0 , 180 )); Lua particlesanim : addInit ( ParticleRotationInit ( 0 , 180 )) ParticleAlphaInit \u00b6 It can be used to set particle transparency. When set 0 is total transparent particle, when set 1 is total opaque particle. Class default constructor: ParticleAlphaInit(float minAlpha, float maxAlpha) C++ particlesanim -> addInit ( new ParticleAlphaInit ( 0 , 0.5 )) Lua particlesanim : addInit ( ParticleAlphaInit ( 0 , 0.5 )) ParticleColorInit \u00b6 Can be used to set inittial color of particle. Class default constructor: ParticleColorInit(float minRed, float minGreen, float minBlue, float maxRed, float maxGreen, float maxBlue) C++ particlesanim -> addInit ( new ParticleColorInit ( 0 , 0 , 0 , 1 , 1 , 0 )) Lua particlesanim : addInit ( ParticleColorInit ( 0 , 0 , 0 , 1 , 1 , 0 )) ParticleSizeInit \u00b6 Every particle can have its size. This class is used to set inittial size of particle. Class default constructor: ParticleSizeInit(float minSize, float maxSize) C++ particlesanim -> addInit ( new ParticleSizeInit ( 50 , 100 )) Lua particlesanim : addInit ( ParticleSizeInit ( 50 , 100 )) ParticleSpriteInit \u00b6 A particle can also have a sprite. The sprite of particle is set by an integer and during particle creation the inittial sprite is sorted. In Supernova we call sprite as a rect of sprite sheet. More details you can see in sprite section. Class default constructor: ParticleSpriteInit(std::vector frames) C++ std :: vector < int > sprites ; sprites . push_back ( 1 ); sprites . push_back ( 0 ); sprites . push_back ( 2 ); particlesanim -> addInit ( new ParticleSpriteInit ( sprites )); Lua particlesanim -> addInit ( ParticleSpriteInit ({ 1 , 0 , 2 })); ParticleVelocityInit \u00b6 It's the inittial velocity of particle. Class default constructor: ParticleVelocityInit(Vector3 minVelocity, Vector3 maxVelocity) C++ particlesanim -> addInit ( new ParticleVelocityInit ( Vector3 ( - 15 , - 4 , 0 ), Vector3 ( 15 , 24 , 0 ))) Lua particlesanim : addInit ( ParticleVelocityInit ( Vector3 ( - 15 , - 4 , 0 ), Vector3 ( 15 , 24 , 0 ))) ParticleAccelerationInit \u00b6 It's to set inittal acceleration of particle with this class. Class default constructor: ParticleAccelerationInit(Vector3 minAcceleration, Vector3 maxAcceleration) C++ particlesanim -> addInit ( new ParticleAccelerationInit ( Vector3 ( 0.0f , 9.81f * 5 , 0.0f ), Vector3 ( 0.0f , 9.81f * 5 , 0.0f ))); Lua particlesanim : addInit ( ParticleAccelerationInit ( Vector3 ( 0.0 f , 9.81 f * 5 , 0.0 f ), Vector3 ( 0.0 f , 9.81 f * 5 , 0.0 f )))","title":"Particle system"},{"location":"learning/particle-system/#particle-initializers","text":"","title":"Particle Initializers"},{"location":"learning/particle-system/#particlelifeinit","text":"Every particle has its life and this life is regressive. When a particle starts, through this class you can set the lifetime of it. Throughout the life of the particle, when it reaches 0, the particle dies. Class default constructor: ParticleLifeInit(float minLife, float maxLife) C++ particlesanim -> addInit ( new ParticleLifeInit ( 10 , 10 )); Lua particlesanim : addInit ( ParticleLifeInit ( 10 , 10 ))","title":"ParticleLifeInit"},{"location":"learning/particle-system/#particlepositioninit","text":"The inittial position of particle is set with this class. Class default constructor: ParticlePositionInit(Vector3 minPosition, Vector3 maxPosition) C++ particlesanim -> addInit ( new ParticlePositionInit ( Vector3 ( 100 , 0 , 0 ), Vector3 ( 100 , 100 , 0 ))); Lua particlesanim : addInit ( ParticlePositionInit ( Vector3 ( 100 , 0 , 0 ), Vector3 ( 100 , 100 , 0 )))","title":"ParticlePositionInit"},{"location":"learning/particle-system/#particlerotationinit","text":"The inittial rotation of particle is set with this class. The engine default is degress, but it can be changed. Class default constructor: ParticleRotationInit(float minRotation, float maxRotation) C++ particlesanim -> addInit ( new ParticleRotationInit ( 0 , 180 )); Lua particlesanim : addInit ( ParticleRotationInit ( 0 , 180 ))","title":"ParticleRotationInit"},{"location":"learning/particle-system/#particlealphainit","text":"It can be used to set particle transparency. When set 0 is total transparent particle, when set 1 is total opaque particle. Class default constructor: ParticleAlphaInit(float minAlpha, float maxAlpha) C++ particlesanim -> addInit ( new ParticleAlphaInit ( 0 , 0.5 )) Lua particlesanim : addInit ( ParticleAlphaInit ( 0 , 0.5 ))","title":"ParticleAlphaInit"},{"location":"learning/particle-system/#particlecolorinit","text":"Can be used to set inittial color of particle. Class default constructor: ParticleColorInit(float minRed, float minGreen, float minBlue, float maxRed, float maxGreen, float maxBlue) C++ particlesanim -> addInit ( new ParticleColorInit ( 0 , 0 , 0 , 1 , 1 , 0 )) Lua particlesanim : addInit ( ParticleColorInit ( 0 , 0 , 0 , 1 , 1 , 0 ))","title":"ParticleColorInit"},{"location":"learning/particle-system/#particlesizeinit","text":"Every particle can have its size. This class is used to set inittial size of particle. Class default constructor: ParticleSizeInit(float minSize, float maxSize) C++ particlesanim -> addInit ( new ParticleSizeInit ( 50 , 100 )) Lua particlesanim : addInit ( ParticleSizeInit ( 50 , 100 ))","title":"ParticleSizeInit"},{"location":"learning/particle-system/#particlespriteinit","text":"A particle can also have a sprite. The sprite of particle is set by an integer and during particle creation the inittial sprite is sorted. In Supernova we call sprite as a rect of sprite sheet. More details you can see in sprite section. Class default constructor: ParticleSpriteInit(std::vector frames) C++ std :: vector < int > sprites ; sprites . push_back ( 1 ); sprites . push_back ( 0 ); sprites . push_back ( 2 ); particlesanim -> addInit ( new ParticleSpriteInit ( sprites )); Lua particlesanim -> addInit ( ParticleSpriteInit ({ 1 , 0 , 2 }));","title":"ParticleSpriteInit"},{"location":"learning/particle-system/#particlevelocityinit","text":"It's the inittial velocity of particle. Class default constructor: ParticleVelocityInit(Vector3 minVelocity, Vector3 maxVelocity) C++ particlesanim -> addInit ( new ParticleVelocityInit ( Vector3 ( - 15 , - 4 , 0 ), Vector3 ( 15 , 24 , 0 ))) Lua particlesanim : addInit ( ParticleVelocityInit ( Vector3 ( - 15 , - 4 , 0 ), Vector3 ( 15 , 24 , 0 )))","title":"ParticleVelocityInit"},{"location":"learning/particle-system/#particleaccelerationinit","text":"It's to set inittal acceleration of particle with this class. Class default constructor: ParticleAccelerationInit(Vector3 minAcceleration, Vector3 maxAcceleration) C++ particlesanim -> addInit ( new ParticleAccelerationInit ( Vector3 ( 0.0f , 9.81f * 5 , 0.0f ), Vector3 ( 0.0f , 9.81f * 5 , 0.0f ))); Lua particlesanim : addInit ( ParticleAccelerationInit ( Vector3 ( 0.0 f , 9.81 f * 5 , 0.0 f ), Vector3 ( 0.0 f , 9.81 f * 5 , 0.0 f )))","title":"ParticleAccelerationInit"},{"location":"learning/screen-scaling/","text":"To handle with the variety of resolutions and screen sizes of devices, Supernova have some options to choose the better scaling mode. All project code you must declare the size of canvas: C++: Supernova::setCanvasSize(1000,480) Lua: Supernova.setCanvasSize(1000,480) This is the base size you must use for design your project. For 3D projects this is used only for perspective view aspect, but for 2D projects this sizes are very important to positioning objects in screen. It`s also important know Supernova uses the origin of coordinates at bottom-left of canvas. This image represents an abstract canvas: There are 5 types of scaling mode divided by 2 categories: Dynamic canvas size modes \u00b6 FitWidth \u00b6 This is default mode. This keeps canvas width but floats height. Canvas can be changed from original format, but only height changes. Should be used getPreferedCanvasWidth() and getPreferedCanvasHeight() to get original canvas size. C++: Engine::setScalingMode(Scaling::FITWIDTH) Lua: Engine.setScalingMode(Engine.SCALING_FITWIDTH) FitHeight \u00b6 It is similar to FitWidth. This keeps canvas height but floats width. Canvas can be changed from original format, but only width changes. Should be used getPreferedCanvasWidth() and getPreferedCanvasHeight() to get original canvas size. C++: Engine::setScalingMode(Scaling::FITHEIGHT) Lua: Engine.setScalingMode(Engine.SCALING_FITHEIGHT) Static canvas size modes \u00b6 Letterbox \u00b6 This keeps canvas width and height but empty spaces can be show on screen. C++: Engine::setScalingMode(Scaling::LETTERBOX) Lua: Engine.setScalingMode(Engine.SCALING_LETTERBOX) Crop \u00b6 This keeps canvas width and height but part of canvas can be out of screen (not in visible area). C++: Engine::setScalingMode(Scaling::CROP) Lua: Engine.setScalingMode(Engine.SCALING_CROP) Stretch \u00b6 This keeps canvas width and height but scene objects can deform. C++: Engine::setScalingMode(Scaling::STRETCH) Lua: Engine.setScalingMode(Engine.SCALING_STRETCH)","title":"Screen scaling"},{"location":"learning/screen-scaling/#dynamic-canvas-size-modes","text":"","title":"Dynamic canvas size modes"},{"location":"learning/screen-scaling/#fitwidth","text":"This is default mode. This keeps canvas width but floats height. Canvas can be changed from original format, but only height changes. Should be used getPreferedCanvasWidth() and getPreferedCanvasHeight() to get original canvas size. C++: Engine::setScalingMode(Scaling::FITWIDTH) Lua: Engine.setScalingMode(Engine.SCALING_FITWIDTH)","title":"FitWidth"},{"location":"learning/screen-scaling/#fitheight","text":"It is similar to FitWidth. This keeps canvas height but floats width. Canvas can be changed from original format, but only width changes. Should be used getPreferedCanvasWidth() and getPreferedCanvasHeight() to get original canvas size. C++: Engine::setScalingMode(Scaling::FITHEIGHT) Lua: Engine.setScalingMode(Engine.SCALING_FITHEIGHT)","title":"FitHeight"},{"location":"learning/screen-scaling/#static-canvas-size-modes","text":"","title":"Static canvas size modes"},{"location":"learning/screen-scaling/#letterbox","text":"This keeps canvas width and height but empty spaces can be show on screen. C++: Engine::setScalingMode(Scaling::LETTERBOX) Lua: Engine.setScalingMode(Engine.SCALING_LETTERBOX)","title":"Letterbox"},{"location":"learning/screen-scaling/#crop","text":"This keeps canvas width and height but part of canvas can be out of screen (not in visible area). C++: Engine::setScalingMode(Scaling::CROP) Lua: Engine.setScalingMode(Engine.SCALING_CROP)","title":"Crop"},{"location":"learning/screen-scaling/#stretch","text":"This keeps canvas width and height but scene objects can deform. C++: Engine::setScalingMode(Scaling::STRETCH) Lua: Engine.setScalingMode(Engine.SCALING_STRETCH)","title":"Stretch"}]}